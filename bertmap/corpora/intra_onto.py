"""
Ontology Corpus class from within the input ontology.

Data structure illustration:
{   
    ...,
    class_label:{ 
        synonyms: []
        soft_nonsynonyms: []
        hard_nonsynonyms: []
    },
    ...
}

Notes: We only store the forward synonyms, i.e. given a list of labels from a class C, we store (a_i, a_{j>i});
the backward synonyms can be easily generated by reversing the forward synonyms and the identity synonyms are just duplicated keys.
"""


from bertmap.onto import Ontology
from bertmap.utils import uniqify, exclude_randrange, random_drop
from bertmap.corpora import OntologyCorpus
import random
import itertools
from copy import deepcopy
from collections import defaultdict


class IntraOntoCorpus(OntologyCorpus):

    def __init__(self, onto_path, onto_class2text_tsv=None, properties=["label"], sample_rate=5, corpus_path=None):
        super().__init__(onto_path, onto_class2text_tsv, properties, sample_rate, corpus_path=corpus_path)
        
    def init_config(self, onto_path, onto_class2text_tsv=None, properties=["label"], sample_rate=5):
        self.ontology = Ontology(onto_path)
        self.class2text = Ontology.load_class2text(onto_class2text_tsv) if onto_class2text_tsv \
            else self.ontology.create_class2text(*properties)
        self.corpus_dict = defaultdict(lambda:self.term_dict())
        self.onto_name = self.ontology.iri_abbr.replace(":", "")
        self.corpus_type = "intra-onto"
        # rate for sampling the random (soft) nonsynonym
        self.sample_rate = sample_rate

    def create_corpus(self):
        self.report_strings = []
        self.intra_onto_synonyms()
        self.intra_onto_soft_nonsynonyms(sample_rate=self.sample_rate)
        self.intra_onto_hard_nonsynonyms()
        self.corpus_dict[" corpus_info "] = {"corpus_type": "Intra-ontology Corpus", 
                                             "corpus_onto": self.onto_name, 
                                             "synonyms": self.synonym_count,
                                             "id_synonyms": len(self.corpus_dict),
                                             "soft_nonsynonyms": self.soft_nonsynonym_count,
                                             "hard_nonsynonyms": self.hard_nonsynonym_count,
                                             "num_violated": len(self.soft_violation) + len(self.hard_violation)}
        self.report(self.corpus_dict)
          
    def intra_onto_synonyms(self):
        """The synonyms include identity, forward and backward as :
                (a_i, a_i); [(a_i, a_{j>i}); (a_i, a_{j<i})
           but we only need to store the *forward* because the rest can be easily generated from 
           the dictionary data structure. 
        """
        self.synonym_count = 0
        for _, dp in self.class2text.iterrows():
            class_text = dp["Class-Text"]
            label_list, num_labels = Ontology.parse_class_text(class_text)
            for i in range(num_labels):
                pos_label = label_list[i]
                ##### For generating the synonyms #####
                pos_term_dict = self.corpus_dict[pos_label]
                rest_aliases = label_list[i+1:]  # consider only forward synonyms
                pos_term_synonyms = deepcopy(pos_term_dict["synonyms"])
                assert pos_term_synonyms is not pos_term_dict["synonyms"]
                existed_num = len(pos_term_synonyms)
                pos_term_synonyms += rest_aliases  # update the synonyms for ith label term
                pos_term_synonyms = uniqify(pos_term_synonyms)  # remove duplicates
                self.synonym_count += len(pos_term_synonyms) - existed_num  # add the increment number
                ##### Update the dictionary #####
                pos_term_dict["synonyms"] = pos_term_synonyms
                self.corpus_dict[pos_label] = pos_term_dict

    def intra_onto_soft_nonsynonyms(self, sample_rate=5):
        self.soft_nonsynonym_count = 0
        self.soft_violation = []
        for k, dp in self.class2text.iterrows():
            class_text = dp["Class-Text"]
            label_list, _ = Ontology.parse_class_text(class_text)
            for pos_label in label_list:
                ##### For generating the soft nonsynonyms #####
                pos_term_dict = self.corpus_dict[pos_label]
                pos_term_soft_nonsynonyms = deepcopy(pos_term_dict["soft_nonsynonyms"])
                assert pos_term_soft_nonsynonyms is not pos_term_dict["soft_nonsynonyms"]
                existed_num = len(pos_term_soft_nonsynonyms)
                neg_class_inds = [exclude_randrange(0, len(self.class2text), exclude=k) for _ in range(sample_rate-1)]
                assert k not in neg_class_inds  # randomsly sample R class ids that is not the current class id k
                for nid in neg_class_inds:
                    neg_label_list, neg_label_num = Ontology.parse_class_text(self.class2text.iloc[nid]["Class-Text"])
                    neg_label_ind = random.randrange(0, neg_label_num)  # randomly pick a label from the negative cclass
                    neg_label = neg_label_list[neg_label_ind]
                    if self.negative_sample_check(pos_label, neg_label):
                        pos_term_soft_nonsynonyms.append(neg_label)
                    else:
                        self.soft_violation.append([pos_label, neg_label])
                pos_term_soft_nonsynonyms = uniqify(pos_term_soft_nonsynonyms)
                self.soft_nonsynonym_count += len(pos_term_soft_nonsynonyms) - existed_num
                ##### Update the dictionary #####
                pos_term_dict["soft_nonsynonyms"] = pos_term_soft_nonsynonyms
                self.corpus_dict[pos_label] = pos_term_dict


    def intra_onto_hard_nonsynonyms(self, max_num=10):
        classes = list(self.ontology.onto.classes())
        self.hard_nonsynonym_count = 0
        self.hard_violation = []
        for cl in classes:
            sub_classes = list(cl.subclasses())
            if len(sub_classes) <= 1:
                continue
            # with at least two sibiling classes we can extract hard negatives
            sib_labels = []  # [[sibiling class 1's labels], [sibling class 2's labels], ...]
            for scl in sub_classes:
                encoded_labels = Ontology.encode_class_text(scl, "label")
                label_list, _ = Ontology.parse_class_text(encoded_labels)
                sib_labels.append(label_list)
            # e.g. sibling1: ["a", "b"]; sibling2: ["c"] -> [("a", "c"), ("b", "c")] as forward
            for i in range(len(sib_labels)):
                for j in range(i+1, len(sib_labels)):
                    pairs_from_sibling_classes = list(itertools.product(sib_labels[i], sib_labels[j]))
                    for pos_label, neg_label in pairs_from_sibling_classes:
                        ##### For generating the hard nonsynonyms #####
                        pos_term_dict = self.corpus_dict[pos_label]
                        pos_term_hard_nonsynonyms = deepcopy(pos_term_dict["hard_nonsynonyms"])
                        assert pos_term_hard_nonsynonyms is not pos_term_dict["hard_nonsynonyms"]
                        existed_num = len(pos_term_hard_nonsynonyms)
                        if self.negative_sample_check(pos_label, neg_label):
                            pos_term_hard_nonsynonyms.append(neg_label)
                        else:
                            self.hard_violation.append([pos_label, neg_label])
                        pos_term_hard_nonsynonyms = uniqify(pos_term_hard_nonsynonyms)
                        # a simple strategy to reduce the influence of deep-level sibling classes
                        while len(pos_term_hard_nonsynonyms) > max_num:
                            pos_term_hard_nonsynonyms = random_drop(pos_term_hard_nonsynonyms)
                        self.hard_nonsynonym_count += len(pos_term_hard_nonsynonyms) - existed_num
                        ##### Update the dictionary #####
                        pos_term_dict["hard_nonsynonyms"] = pos_term_hard_nonsynonyms
                        self.corpus_dict[pos_label] = pos_term_dict
        